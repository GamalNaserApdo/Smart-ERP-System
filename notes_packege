packege used in the project

1. State Management: flutter_bloc
الوصف الرسمي
هي مكتبة إدارة حالة (State Management) تساعد على فصل واجهة المستخدم (Presentation) عن منطق العمل (Business Logic) بطريقة سريعة وقابلة للاختبار ولإعادة الاستخدام. تعتمد على مفهوم الـ Streams.
الاستخدام في الحياة العملية
•	الوظيفة: تحويل الأحداث (Events) القادمة من المستخدم (مثل ضغطة زر) إلى حالات (States) تظهر على الشاشة (مثل Loading, Success, Error).
•	متى تستخدمها؟ في أي شاشة تحتاج تفاعلاً معقداً أو جلب بيانات. هي العمود الفقري للتطبيق.
•	المكان في المشروع: تقع في Presentation Layer (طبقة العرض)، وتتحدث مع الـ UseCases أو Repositories.
•	بتحل مشكلة إيه؟ الفوضى التي تحدث عند استخدام setState في التطبيقات الكبيرة، وتسهل اختبار الكود (Unit Testing) لأن المنطق مفصول عن الـ UI.
العلاقة مع باقي الباكجات
•	التكامل: تعتمد على get_it للحصول على الـ Dependencies (مثل Repository).
•	Clean Architecture: هي المسؤولة عن الربط بين الـ UI والـ Domain Layer. تستلم Either من dartz وتقرر الحالة بناءً عليه (Success أو Failure).
الشرح داخل الكود (Conceptual)
الـ Bloc عبارة عن صندوق أسود: تدخل له Event ويخرج منه State.
Dart
// Event: المستخدم طلب تسجيل الدخول
context.read<LoginBloc>().add(LoginButtonPressed(email, password));

// UI: الـ BlocBuilder بيسمع للتغييرات
BlocBuilder<LoginBloc, LoginState>(
  builder: (context, state) {
    if (state is LoginLoading) {
      return CircularProgressIndicator(); // اعرض تحميل
    } else if (state is LoginSuccess) {
      return HomeScreen(); // انتقل للصفحة التالية
    } else if (state is LoginFailure) {
      return Text(state.errorMessage); // اعرض الخطأ
    }
    return Container();
  },
)
ملاحظات وأخطاء شائعة
•	خطأ: وضع منطق UI (مثل Navigator.push أو ShowDialog) داخل الـ Bloc مباشرة.
o	الحل: استخدم BlocListener لهذه الأمور في الـ UI، واترك الـ Bloc يتعامل مع البيانات والحالات فقط.
•	تنبيه: لا تنسَ إغلاق الـ Blocs إذا كنت تنشئها يدوياً (لكن BlocProvider غالباً يقوم بذلك نيابة عنك).
________________________________________
2. Networking: dio
الوصف الرسمي
عميل HTTP قوي لـ Dart، يدعم Interceptors، Global Configuration، FormData، Request Cancellation، وتحميل الملفات.
الاستخدام في الحياة العملية
•	الوظيفة: هو "ساعي البريد" الذي يأخذ طلبك للسيرفر (API) ويحضر الرد.
•	ليه مش http العادية؟ لأن dio يوفر مميزات متقدمة جداً بجهد أقل، مثل التعامل مع الـ Refresh Token تلقائياً، وعرض الـ Logs بشكل منسق.
•	المكان في المشروع: يقع في Data Layer (تحديداً Remote Data Source).
العلاقة مع باقي الباكجات
•	يتم حقنه في المشروع بواسطة get_it.
•	يُستخدم عادة مع مكتبة retrofit (اختيارية لكن شائعة) لتسهيل كتابة الـ APIs.
الشرح داخل الكود (Conceptual)
بدلاً من كتابة Headers وتفاصيل في كل طلب، نقوم بإعداد dio مرة واحدة.
Dart
// إعداد مرة واحدة (Singleton)
final dio = Dio(BaseOptions(
  baseUrl: 'https://api.example.com',
  connectTimeout: Duration(seconds: 5),
));

// إضافة Interceptor (مثلاً لطباعة أي خطأ يحدث)
dio.interceptors.add(LogInterceptor());

// الاستخدام
try {
  final response = await dio.get('/users');
  return response.data; // البيانات جاهزة
} on DioException catch (e) {
  // Dio بيوفر أنواع أخطاء محددة (Timeout, Bad Response, etc.)
  handleError(e);
}
ملاحظات وأخطاء شائعة
•	خطأ: إنشاء نسخة جديدة من Dio في كل Request.
o	الحل: يجب أن يكون Singleton (نسخة واحدة) ويحقن عبر get_it.
•	تنبيه: تأكد من التعامل مع DioException بشكل منفصل عن الأخطاء العادية لضمان معالجة مشاكل الشبكة بدقة.
________________________________________
3. Dependency Injection: get_it & injectable
الوصف الرسمي
•	get_it: هي Service Locator بسيط (مكان مركزي لتخزين واستدعاء الكلاسات).
•	injectable: هو مولد كود (Code Generator) يقوم بكتابة كود ربط الـ get_it نيابة عنك باستخدام الـ Annotations.
الاستخدام في الحياة العملية
•	بتحل مشكلة إيه؟ مشكلة الـ "Spaghetti Code" والاعتمادية المباشرة (Tight Coupling). بدلاً من كتابة new Repository() في كل مكان، تطلب الـ Instance من get_it.
•	متى تستخدمها؟ من أول يوم في المشروع.
•	المكان في المشروع: هي "الصمغ" الذي يربط كل طبقات المشروع ببعضها.
العلاقة مع باقي الباكجات
•	تعتمد على build_runner و injectable_generator لتوليد ملف التهيئة.
الشرح داخل الكود (Conceptual)
بدلاً من كتابة كود طويل لتسجيل كل كلاس، نستخدم injectable.
كيف تكتب الكود:
Dart
@injectable // يا injectable، جهز لي الكلاس ده عشان أقدر أستخدمه
class UserRepository {
  final Dio dio;
  UserRepository(this.dio); // هيعرف لوحده يجيب dio منين
}
كيف تستخدمه:
Dart
// بدلاً من: final repo = UserRepository(Dio());
final repo = getIt<UserRepository>(); // هات لي النسخة الجاهزة
ملاحظات وأخطاء شائعة
•	خطأ: نسيان تشغيل أمر البناء flutter pub run build_runner build بعد إضافة كلاس جديد.
•	نصيحة: افهم الفرق بين @singleton (نفس النسخة دائماً) و @injectable (نسخة جديدة في كل طلب). استخدم @singleton للـ Dio والـ Database، و @injectable للـ Blocs.
________________________________________
4. Functional Programming: dartz
الوصف الرسمي
مكتبة للبرمجة الوظيفية (Functional Programming) في Dart. (رغم أن Dart أصبحت تدعم بعض هذه الميزات، إلا أن dartz ما زالت مشهورة جداً للـ Error Handling).
الاستخدام في الحياة العملية
•	الوظيفة: الاستخدام الأشهر هو كلاس Either<Left, Right>.
•	بتحل مشكلة إيه؟ التخلص من try-catch العشوائي. تجبرك الدالة على إرجاع إما خطأ (Failure) أو بيانات صحيحة (Success)، ولا يمكن تجاهل الخطأ.
•	المكان في المشروع: بشكل مكثف في Domain Layer (Repositories & UseCases).
العلاقة مع باقي الباكجات
•	الـ Repositories ترجع Either.
•	الـ Bloc يستخدم دالة fold لفك هذا الـ Either وتحديد الحالة.
الشرح داخل الكود (Conceptual)
Dart
// الدالة بترجع "إما" فشل "أو" مستخدم
Future<Either<Failure, User>> getUser() async {
  try {
    final result = await api.fetchUser();
    return Right(result); // اليمين دايماً للصح (Right is Right)
  } catch (e) {
    return Left(ServerFailure()); // الشمال للمشاكل
  }
}

// في الـ Bloc
final result = await getUser();
result.fold(
  (failure) => emit(ErrorState(failure.message)), // لو شمال نفذ ده
  (user)    => emit(SuccessState(user)),          // لو يمين نفذ ده
);
ملاحظات وأخطاء شائعة
•	تنبيه: dartz مكتبة كبيرة جداً، لا تحاول تعلم كل شيء فيها في البداية. ركز فقط على Either.
•	مستقبلاً: بدأت تظهر بدائل أحدث مثل fpdart أو ميزة Records و Pattern Matching في Dart 3 التي قد تغني عن dartz في بعض الحالات، لكن معرفة dartz ضرورية لأن معظم الشروحات تستخدمها.
________________________________________
5. Local Storage: hive & hive_flutter
الوصف الرسمي
قاعدة بيانات NoSQL خفيفة جداً، وسريعة للغاية، ومكتوبة بلغة Dart بالكامل (لا تحتاج لـ Native Code).
الاستخدام في الحياة العملية
•	الوظيفة: تخزين البيانات "Offline". مثل: الـ Token، إعدادات التطبيق (Dark Mode)، أو تخزين المنتجات لتصفحها بدون إنترنت (Caching).
•	المكان في المشروع: Data Layer (Local Data Source).
العلاقة مع باقي الباكجات
•	تستخدم hive_generator و build_runner لتوليد الـ Type Adapters (عشان تخزن كلاسات كاملة مش بس String و Int).
الشرح داخل الكود (Conceptual)
البيانات تخزن في "صناديق" (Boxes).
Dart
// 1. فتح الصندوق
var box = await Hive.openBox('settings');

// 2. الكتابة (مثل Map)
box.put('username', 'Ahmed');

// 3. القراءة
var name = box.get('username'); // يرجع 'Ahmed'
ملاحظات وأخطاء شائعة
•	خطأ: نسيان تسجيل الـ Adapter في main.dart قبل فتح الـ Box.
•	تنبيه: Hive ممتازة للبيانات البسيطة والمتوسطة. إذا كانت لديك علاقات معقدة جداً (SQL Relations)، قد تكون Drift (SQLite) خياراً أفضل، لكن Hive أسهل وأسرع للبدء.
________________________________________
6. UI Utilities: cached_network_image
الوصف الرسمي
ويدجت (Widget) لـ Flutter تقوم بتحميل الصور من الويب وتخزينها في الكاش (Cache).
الاستخدام في الحياة العملية
•	بتحل مشكلة إيه؟ بدونها، في كل مرة تقوم بعمل Scroll وتظهر الصورة، سيتم تحميلها من الإنترنت مجدداً! هذا يستهلك باقة المستخدم ويبطئ التطبيق. هذه المكتبة تخزن الصورة على الجهاز بعد أول تحميل.
•	المكان في المشروع: Presentation Layer (UI).
الشرح داخل الكود (Conceptual)
Dart
CachedNetworkImage(
  imageUrl: "http://example.com/image.jpg",
  placeholder: (context, url) => CircularProgressIndicator(), // أثناء التحميل
  errorWidget: (context, url, error) => Icon(Icons.error), // لو حصل خطأ
)
ملاحظات
•	تلقائياً تقوم بإدارة الذاكرة، فلا تقلق بشأن امتلاء الجهاز بالصور (لها حد معين).
________________________________________
7. Dev Dependencies: build_runner & Generators
هذه المجموعة (build_runner, injectable_generator, hive_generator) لا تدخل في التطبيق النهائي الذي يرفع على الستور، بل هي أدوات للمطور فقط.
build_runner
•	الوظيفة: هو "المدير" الذي يشرف على عملية توليد الكود. هو الذي ينفذ الأمر: "يا generators اشتغلوا وطلعوا الكود".
•	الأمر السحري: flutter pub run build_runner build (أو watch ليعمل تلقائياً عند التعديل).
Generators (injectable & hive)
•	injectable_generator: يقرأ ملفاتك بحثاً عن @injectable ويكتب ملف xxx.config.dart.
•	hive_generator: يقرأ ملفاتك بحثاً عن @HiveType ويكتب ملف xxx.g.dart (الـ Adapter).
ملاحظات هامة جداً
•	قاعدة ذهبية: لا تعدل أبداً أي ملف ينتهي بـ .g.dart أو .config.dart بيدك. سيتم مسح تعديلاتك في المرة القادمة التي تشغل فيها الأمر.
________________________________________
8. توصيات إضافية (Highly Recommended Packages)
لإكمال هذا الـ Stack القوي، أنصحك بشدة بإضافة الباكجات التالية:
1. freezed & freezed_annotation
•	لماذا؟ الرفيق الروحي لـ flutter_bloc. تساعدك في إنشاء States و Events وكلاسات بيانات (Data Classes) غير قابلة للتعديل (Immutable) وتدعم الـ Unions.
•	الفائدة: بدلاً من كتابة if (state is Loading) يدوياً واحتمال الخطأ، freezed تمنحك دوال map و when التي تجبرك على تغطية كل الحالات.
2. flutter_screenutil
•	لماذا؟ لجعل التصميم متجاوب (Responsive) على مختلف أحجام الشاشات بسهولة (تستخدم 10.w بدلاً من 10 بكسل ثابتة).
3. auto_route أو go_router
•	لماذا؟ الـ Navigator العادي في Flutter جيد، لكن عند التعامل مع الـ Deep Links، والـ Nested Navigation (تابات بداخل تابات)، وتمرير البيانات، تصبح هذه المكتبات ضرورة لترتيب التنقل.
________________________________________
9. الخلاصة: كيف تعمل هذه الأوركسترا معاً؟
في مشروع Clean Architecture نموذجي:
1.	UI: يعرض الصور بـ cached_network_image.
2.	يحدث حدث (Event)، فيرسله للـ Bloc.
3.	Bloc: يطلب البيانات من الـ UseCase (مستخدمًا get_it للوصول إليه).
4.	UseCase: يطلب البيانات من الـ Repository.
5.	Repository: يقرر هل يجلب البيانات من:
o	Hive (لو مفيش نت أو عايز يعرض كاش).
o	Dio (لو عايز داتا حديثة من السيرفر).
6.	النتيجة تعود مغلفة بـ dartz (Either).
7.	الـ Bloc يفك الـ Either ويحدث الـ State.
8.	المستخدم يرى النتيجة.

